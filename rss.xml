<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>QC3284&apos;s Blog</title><description>乐于分享</description><link>https://blog.xcqcoo.top/</link><language>zh_CN</language><item><title>X-wrt SSH Open</title><link>https://blog.xcqcoo.top/posts/x-wrt-ssh-open/</link><guid isPermaLink="true">https://blog.xcqcoo.top/posts/x-wrt-ssh-open/</guid><description>如何开启X-wrt的SSH</description><pubDate>Fri, 09 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;文章来源：https://github.com/x-wrt/x-wrt.github.io/tree/master/docs/ssh-open&lt;/p&gt;
&lt;h1&gt;X-WRT 开启ssh的方法&lt;/h1&gt;
&lt;p&gt;很多⼈说 X-WRT 的ssh无法登录，这其实是因为默认的ssh没有开启用户登录，大家可以进入界面，进入&lt;a href=&quot;#&quot;&gt;系统-管理权&lt;/a&gt;页面，进入&lt;a href=&quot;#&quot;&gt;SSH访问&lt;/a&gt;标签，开启&lt;strong&gt;密码验证&lt;/strong&gt;和&lt;strong&gt;允许 root 用户凭密码登录&lt;/strong&gt;就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn2.xcqcoo.top/gh/x-wrt/x-wrt.github.io@master/docs/ssh-open/ssh1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意请使用谷歌浏览器，火狐浏览器，微软的浏览器，其他浏览器存在不可预知的问题。&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>X-wrt 多拨和负载均衡</title><link>https://blog.xcqcoo.top/posts/x-wrt-duobo/</link><guid isPermaLink="true">https://blog.xcqcoo.top/posts/x-wrt-duobo/</guid><description>X-wrt 多拨和负载均衡教程</description><pubDate>Fri, 09 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;文章来源：https://github.com/x-wrt/x-wrt.github.io/master/docs/xwan/&lt;/p&gt;
&lt;h1&gt;多拨和负载均衡配置教程&lt;/h1&gt;
&lt;h2&gt;1. 介绍(单网口多拨)&lt;/h2&gt;
&lt;p&gt;很多⼈不知道怎么配置OpenWrt多拨，特写⼀个简易的教程，只要你的运营商⽀持多拨，照着这个教程做都可以多拨叠加⽹速。本教程适用于OpenWrt衍生版本&lt;a href=&quot;https://downloads.x-wrt.com/rom/&quot;&gt;X-WRT的固件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意请使用谷歌浏览器，火狐浏览器，微软的浏览器，其他浏览器存在不可预知的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.1 首先，正常设置好wan口拨号上网&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;#&quot;&gt;网络-接口&lt;/a&gt;页面，编辑&lt;a href=&quot;#&quot;&gt;wan口-基本设置&lt;/a&gt;，选择协议PPPoE，填写宽带账户密码:
&lt;img src=&quot;https://cdn2.xcqcoo.top/gh/x-wrt/x-wrt.github.io@master/docs/xwan/xwan-pppoe1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;a href=&quot;#&quot;&gt;wan口-高级设置&lt;/a&gt;，使用网关跃点 填写&lt;code&gt;40&lt;/code&gt;，&lt;a href=&quot;#&quot;&gt;防火墙设置&lt;/a&gt; 选择wan
&lt;img src=&quot;https://cdn2.xcqcoo.top/gh/x-wrt/x-wrt.github.io@master/docs/xwan/xwan-pppoe2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;1.2 然后，开启多拨&lt;/h3&gt;
&lt;p&gt;进入&lt;a href=&quot;#&quot;&gt;网络-多拨&lt;/a&gt;页面，开启多拨，填写想要的多拨数，启用自动负载均衡和叠加:
&lt;img src=&quot;https://cdn2.xcqcoo.top/gh/x-wrt/x-wrt.github.io@master/docs/xwan/xwan1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;开启多拨后，它会自动设置好负载均衡和叠加，对于高级用户，可以进入&lt;a href=&quot;#&quot;&gt;网络-负载均衡&lt;/a&gt;页面进行高级的调整，小白用户可以忽略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS: 这里开启多拨，实际上用的网口就是1.1设置的wan口的接口&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>X-wrt luci-app-fakemesh</title><link>https://blog.xcqcoo.top/posts/x-wrt-luci-app-fakemesh/</link><guid isPermaLink="true">https://blog.xcqcoo.top/posts/x-wrt-luci-app-fakemesh/</guid><description>X-wrt luci-app-fakemesh介绍及使用教程</description><pubDate>Fri, 09 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;文章来源：https://github.com/x-wrt/com.x-wrt/tree/master/luci-app-fakemesh&lt;/p&gt;
&lt;h2&gt;fakemesh简介&lt;/h2&gt;
&lt;p&gt;fakemesh是一种网络拓扑结构，由一个&lt;code&gt;控制器（AC）&lt;/code&gt;和一个或多个&lt;code&gt;有线AP（Wired AP）&lt;/code&gt;和&lt;code&gt;卫星（Agent）&lt;/code&gt;组成。它是一种混合了&lt;code&gt;无线Mesh&lt;/code&gt;和&lt;code&gt;AC+AP&lt;/code&gt;两种组网模式的混合网络，其中，&lt;code&gt;有线AP&lt;/code&gt;通过网线和&lt;code&gt;控制器（AC）&lt;/code&gt;相连，而&lt;code&gt;卫星（Agent）&lt;/code&gt;则通过无线STA方式接入，共同构成一个无线（包括有线）覆盖网络。&lt;/p&gt;
&lt;p&gt;fakemesh的部署确实相对较为方便，只需要将节点设备连接到正确的网络，并设置节点设备的角色，Mesh ID等信息即可。因为fakemesh结合了无线Mesh和AC+AP两种组网模式，所以也可以很方便地进行混合组网，提高了网络的覆盖范围和可靠性。&lt;/p&gt;
&lt;p&gt;目前&lt;a href=&quot;https://github.com/x-wrt/x-wrt&quot;&gt;X-WRT&lt;/a&gt;默认集成了fakemesh功能&lt;/p&gt;
&lt;h2&gt;fakemesh 使用&lt;/h2&gt;
&lt;h3&gt;组网成功后统一的访问设备的地址格式如下:&lt;/h3&gt;
&lt;p&gt;访问控制器的地址: &lt;code&gt;http://controller.fakemesh/&lt;/code&gt;或者&lt;code&gt;http://ac.fakemesh/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;访问AP的地址: &lt;code&gt;http://{mac}.ap.fakemesh/&lt;/code&gt; 或者 &lt;code&gt;http://N.ap.fakemesh/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;{mac}&lt;/code&gt;是AP的MAC地址，比如&lt;code&gt;{mac}=1122334455AB&lt;/code&gt;，&lt;code&gt;N&lt;/code&gt;是AP的自动编号，比如 N=1, N=2, N=3, ...&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://1.ap.fakemesh/
http://1122334455AB.ap.fakemesh/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;故障处理:&lt;/h3&gt;
&lt;p&gt;AP离线3分钟左右进入故障模式，这个模式开启默认SSID，可以提供接入管理重新配置。
故障模式的默认SSID和密码是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SSID: X-WRT_XXXX
PASSWD: 88888888
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;故障模式下AP的管理IP地址是DHCP的网关地址，比如电脑获取到&lt;code&gt;192.168.16.x&lt;/code&gt;的IP，那么AP的管理IP就是&lt;code&gt;192.168.16.1&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;fakemesh 基本组成&lt;/h2&gt;
&lt;p&gt;组网由一个&lt;code&gt;控制器(controller)&lt;/code&gt;和一个或者多个&lt;code&gt;AP&lt;/code&gt;组成&lt;/p&gt;
&lt;p&gt;AP包括: &lt;code&gt;卫星(Agent)&lt;/code&gt;和&lt;code&gt;有线AP(Wired AP)&lt;/code&gt;两种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制器(Controller)&lt;/strong&gt;:  作为AC和出口路由器，提供网络出口上网，统一管理下挂的卫星和有线AP，统一管理无线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卫星(Agent)&lt;/strong&gt;:  通过Wi-Fi组网接入的AP&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有线AP(Wired AP)&lt;/strong&gt;:  通过网线组网接入的AP&lt;/p&gt;
&lt;h2&gt;fakemesh 配置参数&lt;/h2&gt;
&lt;h3&gt;1. Mesh ID&lt;/h3&gt;
&lt;p&gt;这个参数是fakemesh网络组网的统一ID，控制器、卫星、有线AP都要设置相同的Mesh ID。&lt;/p&gt;
&lt;h3&gt;2. 密钥(Key)&lt;/h3&gt;
&lt;p&gt;这是组网的统一密钥，组网加密需要，如果不需要加密可以留空白。&lt;/p&gt;
&lt;h3&gt;3. 带宽(Band)&lt;/h3&gt;
&lt;p&gt;这是组网使用的无线频段，要设置相同，5G或者2G。&lt;/p&gt;
&lt;h3&gt;4. 角色(Role)&lt;/h3&gt;
&lt;p&gt;可以是控制器、卫星、有线AP。&lt;/p&gt;
&lt;h3&gt;5. 同步配置(Sync Config)&lt;/h3&gt;
&lt;p&gt;是否统一管理Wi-Fi配置等，Wi-Fi配置由控制器统一配置管理。&lt;/p&gt;
&lt;h3&gt;6. 访问 IP 地址(Access IP address)&lt;/h3&gt;
&lt;p&gt;设置一个特定的IP地址给控制器，可以通过这个IP访问控制器的管理界面。&lt;/p&gt;
&lt;h3&gt;7. 关闭前传(Fronthaul Disabled)&lt;/h3&gt;
&lt;p&gt;这个节点关闭前传无线信号，也就是不允许其他AP节点通过这个节点Wi-Fi接入。&lt;/p&gt;
&lt;h3&gt;8. 漫游组件(Band Steer Helper)&lt;/h3&gt;
&lt;p&gt;目前可以选择&lt;a href=&quot;https://github.com/fakemesh/dawn&quot;&gt;DAWN&lt;/a&gt;或者&lt;a href=&quot;https://github.com/fakemesh/usteer&quot;&gt;usteer&lt;/a&gt;作为漫游辅助控件。&lt;/p&gt;
&lt;h2&gt;无线管理(Wireless Management)&lt;/h2&gt;
&lt;p&gt;可以在控制器界面上统一管理无线，包括增删SSID，设置SSID的加密方式，频宽。&lt;/p&gt;
&lt;h2&gt;控制器(Controller)旁路部署&lt;/h2&gt;
&lt;p&gt;需要注意的是，如果控制器不作为网关出口并且不提供DHCP服务，用户需要手动配置网络设置，包括设置控制器的LAN口IP地址、网关IP和DNS。此外，通常控制器的LAN口会默认启用DHCP客户端，从第三方网关获取IP和网关，如果需要使用静态IP，则需要保证控制器和第三方网关在同一个网段且可以相互通信。否则，就无法实现控制器与其他AP的同步配置。&lt;/p&gt;
</content:encoded></item><item><title>X-wrt install on vps</title><link>https://blog.xcqcoo.top/posts/x-wrt-install-on-vps2/</link><guid isPermaLink="true">https://blog.xcqcoo.top/posts/x-wrt-install-on-vps2/</guid><description>将X-wrt安装到VPS上</description><pubDate>Fri, 09 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;文章来源：https://github.com/x-wrt/x-wrt.github.io/tree/master/docs/install-on-vps2&lt;/p&gt;
&lt;h1&gt;X-WRT 安装部署到VPS上(新)&lt;/h1&gt;
&lt;h3&gt;1. 介绍:&lt;/h3&gt;
&lt;p&gt;本教程旨在介绍如何将 X-WRT 系统部署到云服务器（VPS）上。X-WRT 是一个专为路由器设计的开源系统，具有出色的网络转发优化和友好的配置界面。同时，该系统还提供了许多方便的服务，如 OpenVPN 等，可以轻松地一键部署。&lt;/p&gt;
&lt;p&gt;需要注意的是，本教程适用于大多数 VPS，如 vultr、digitalocean、Amazon 的 AWS、Linode、阿里云、腾讯云等。然而，由于不同云服务商的实际情况不同，您需要灵活应对，根据实际情况做出正确的处理。&lt;/p&gt;
&lt;p&gt;本教程只适用于 X-WRT 固件，可以保证几乎 100% 成功地将 X-WRT 系统部署到所有的 VPS 上。&lt;/p&gt;
&lt;h3&gt;2. 教程:&lt;/h3&gt;
&lt;h4&gt;2.1 固件下载&lt;/h4&gt;
&lt;p&gt;我们选择 x86 64 位 (MBR dos) 或 x86 64 位 (UEFI gpt) 的固件进行部署。您可以从以下链接下载所需的文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://downloads.x-wrt.com/rom/&quot;&gt;https://downloads.x-wrt.com/rom/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刷机所需的文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x-wrt-x86-64-generic-initramfs-kernel.bin
x-wrt-x86-64-generic-ext4-combined.img.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您的系统是 EFI 系统，则还需要下载以下文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x-wrt-x86-64-generic-ext4-combined-efi.img.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2.2 VPS系统部署&lt;/h4&gt;
&lt;p&gt;本教程所涉及的 VPS 系统要求比较宽松，可以是 Ubuntu、CentOS、Debian 或其他类 Unix 系统。&lt;/p&gt;
&lt;h4&gt;2.3 VPS系统的网络配置识别&lt;/h4&gt;
&lt;p&gt;在开始部署之前，我们需要了解 VPS 的 IP 地址是如何分配的。有些 VPS 是通过 DHCP 自动获取 IP 地址，有些是静态配置的，还有一些是双网卡或多网卡的。&lt;/p&gt;
&lt;p&gt;登录 VPS 后，可以使用 &lt;code&gt;ifconfig&lt;/code&gt; 或者 &lt;code&gt;ip addr list&lt;/code&gt; 命令查看 VPS 的网卡 IP 地址。然后，使用命令 &lt;code&gt;grep /etc -nre &amp;lt;IP&amp;gt;&lt;/code&gt; 查找包含此 &lt;code&gt;&amp;lt;IP&amp;gt;&lt;/code&gt; 的文件。如果找到了相关文件，并且文件内容包含静态配置的脚本，那么我们可以确定该 VPS 是静态配置的。否则，它是动态配置的。&lt;/p&gt;
&lt;p&gt;此外，我们还需要观察 VPS 是否具有多个网口。如果是，那么在安装过程中需要特别注意。下面将有进一步的说明。&lt;/p&gt;
&lt;h4&gt;2.4 确定磁盘的路径和分区类型&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;df&lt;/code&gt; 和 &lt;code&gt;mount&lt;/code&gt; 命令可以查看 VPS 的磁盘信息，确定磁盘的第一个分区挂载路径，例如 &lt;code&gt;/dev/sda1&lt;/code&gt;、&lt;code&gt;/dev/vda1&lt;/code&gt;、&lt;code&gt;/dev/xvda1&lt;/code&gt; 等等。需要注意的是，此分区的挂载路径以及可用空间大小，通常情况下此分区挂载在 &lt;code&gt;/&lt;/code&gt; 或者 &lt;code&gt;/boot&lt;/code&gt; 下，而我们在刷机过程中需要将固件等文件保存在此路径下。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;fdisk -l&lt;/code&gt; 命令可以查看分区类型，以确定分区是否为 GPT。如果分区为 GPT，则需要刷写 EFI 固件。但通常情况下分区不是 GPT 类型。&lt;/p&gt;
&lt;h4&gt;2.5 开始刷机&lt;/h4&gt;
&lt;p&gt;以下是刷机所需的文件，您可以使用 wget 命令进行下载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x-wrt-x86-64-generic-initramfs-kernel.bin
x-wrt-x86-64-generic-ext4-combined.img.gz 或者 x-wrt-x86-64-generic-ext4-combined-efi.img.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在刷机之前，需要确定当前系统运行的内核路径。一般来说，这个路径是 &lt;code&gt;/boot/vmlinuz*&lt;/code&gt;。您可以使用 &lt;code&gt;uname -r&lt;/code&gt; 命令查看内核版本。比如，如果路径是 &lt;code&gt;/boot/vmlinuz-4.15.0-111-generic&lt;/code&gt;，那么我们需要把 &lt;code&gt;x-wrt-x86-64-generic-initramfs-kernel.bin&lt;/code&gt; 替换为这个内核：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp x-wrt-x86-64-generic-initramfs-kernel.bin /boot/vmlinuz-4.15.0-111-generic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们需要确定第一个分区的路径，假如第一个分区是 &lt;code&gt;/&lt;/code&gt; 我们把固件拷贝到 &lt;code&gt;/&lt;/code&gt; 保存好，注意保存的名字是 &lt;code&gt;x-wrt.img.gz&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp x-wrt-x86-64-generic-ext4-combined.img.gz /x-wrt.img.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时我们还需要一个安装脚本，脚本路径和固件保存的目录相同，这个例子是&lt;code&gt;/&lt;/code&gt; ，脚本名字是 &lt;code&gt;x-wrt-install-vps.sh&lt;/code&gt; 脚本的代码参考如下：（根据情况修改）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh

# install to sda
BDEV=sda

# x-wrt.img.gz in disk part sda1
DDEV=sda1

# static ip
#network=172.21.170.245,255.255.240.0,172.21.175.253,8.8.8.8

# static ip swap eth0 eth1
#network=&quot;117.18.13.159,255.255.255.0,117.18.13.1,8.8.8.8,initscript=dWNpIHNldCBuZXR3b3JrLmxhbi5pZm5hbWU9ZXRoMQp1Y2kgc2V0IG5ldHdvcmsud2FuLmlmbmFtZT1ldGgwCnVjaSBjb21taXQgbmV0d29yawo=&quot;

# dhcp ip
network=dhcp

vmroot=/tmp/block
mkdir -p $vmroot
mount /dev/${DDEV} $vmroot || exit 0
cp $vmroot/x-wrt.img.gz /tmp/x-wrt.img.gz &amp;amp;&amp;amp; {
	cd /
	umount $vmroot
	sync
	(zcat /tmp/x-wrt.img.gz;
	 echo open=443,network=$network;
	) &amp;gt;/dev/$BDEV &amp;amp;&amp;amp; reboot
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个脚本准备刷机的磁盘是sda，第一个分区是sda1，它是DHCP动态获取IP的。你需要根据情况修改刷机脚本，脚本会在重启后启动initramfs内核并且执行。&lt;/p&gt;
&lt;p&gt;如果磁盘是vda，就修改BDEV的值，注意，如果是静态IP，就注释掉&lt;code&gt;network=dhcp&lt;/code&gt;，启用静态IP那一行的&lt;code&gt;network=&amp;lt;ip&amp;gt;,&amp;lt;mask&amp;gt;,&amp;lt;gateway&amp;gt;,&amp;lt;dns&amp;gt;&lt;/code&gt;，如果VPS有多个网卡，比如有2个&lt;code&gt;eth0 eth1&lt;/code&gt;，我们需要附加一个&lt;code&gt;initscript=&amp;lt;script base64 codes&amp;gt;&lt;/code&gt;来做交换网口，这个&lt;code&gt;&amp;lt;script base64 codes&amp;gt;&lt;/code&gt;其实是如下脚本的base64编码，你要根据情况修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uci set network.lan.ifname=eth1
uci set network.wan.ifname=eth0
uci commit network
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果以上操作正确无误，就执行&lt;code&gt;reboot&lt;/code&gt;重启系统。由于我们使用initramfs-kernel替换了原有内核，重启后系统会进入initramfs-kernel环境。然后，该环境会查找 x-wrt-install-vps.sh 脚本并执行刷机操作。这个脚本执行的内容很简单：挂载第一个分区、将固件拷贝到 /tmp 目录中，然后执行刷机并重启。这个过程大概需要5分钟，看情况了。&lt;/p&gt;
&lt;h3&gt;3. 总结:&lt;/h3&gt;
&lt;p&gt;整个刷机过程，大概就三个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载好两个固件文件，保存到特定的路径&lt;/li&gt;
&lt;li&gt;拷贝并且根据情况修改好一个脚本(&lt;code&gt;x-wrt-install-vps.sh&lt;/code&gt;)，保存到特定路径&lt;/li&gt;
&lt;li&gt;重启(reboot)并等待自动安装完成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;系统重启后，你将能够通过访问 X-WRT 的管理界面来配置路由器。以本文的例子为例，管理界面的地址(HTTPS)是 &lt;code&gt;https://[VPS_IP]/&lt;/code&gt;。进入管理界面后，你需要立即修改默认的管理密码。默认的账号/密码是 admin/admin。此外，如果需要，你可以进入系统管理页面，启用 SSH 账户密码登录，并设置防火墙以允许来自 WAN 区域的22端口访问。这样可以使你能够远程登录到路由器并进行更多的配置。&lt;/p&gt;
</content:encoded></item><item><title>如何编译X-WRT</title><link>https://blog.xcqcoo.top/posts/how-to-build-x-wrt/</link><guid isPermaLink="true">https://blog.xcqcoo.top/posts/how-to-build-x-wrt/</guid><description>X-WRT编译教程</description><pubDate>Fri, 09 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;文章来源：https://github.com/x-wrt/x-wrt.github.io/tree/master/docs/build&lt;/p&gt;
&lt;h1&gt;编译教程&lt;/h1&gt;
&lt;p&gt;很多人不知道怎样编译一个自己的固件，这里主要简单介绍大概的编译打包流程，具体的情况还需要大家自己发挥，情况千变万化，大家随机应变。&lt;/p&gt;
&lt;h2&gt;1 编译准备&lt;/h2&gt;
&lt;p&gt;我们建议使用&lt;a href=&quot;https://www.ubuntu.com/&quot;&gt;Ubuntu&lt;/a&gt;系统作为编译环境，这里以Ubuntu 22.04作为例子，其他版本也是可以的。特别注意的是，整个编译过程，都是用普通用户操作，不要用&lt;code&gt;root&lt;/code&gt;用户操作。&lt;/p&gt;
&lt;p&gt;首先要安装编译所需要的软件包:
&lt;code&gt;sudo apt install build-essential ecj fastjar file flex g++ gcc-multilib g++-multilib gawk gettext git git-core java-propose-classpath libelf-dev libncurses5-dev libncursesw5-dev libssl-dev swig python3 python3-dev python3-distutils python3-pyelftools subversion unzip wget zlib1g-dev rsync qemu-utils&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载源码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/x-wrt/x-wrt.git
cd x-wrt

#更新代码tag:
git fetch origin
git fetch origin --tags

#列出可以使用的版本tag:
git tag
#注意摁 q 键结束
#或者直接获取最新发布版本
git describe --tags $(git rev-list --tags --max-count=1)

#选择并切换到指定的版本tag:
git checkout -f &amp;lt;tag-name&amp;gt;
#例如
git checkout -f 21.10_b202112032317
#或者
git checkout -f $(git describe --tags $(git rev-list --tags --max-count=1))

#更新代码:
./scripts/feeds update -a
./scripts/feeds install -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置固件的命令&lt;code&gt;make menuconfig&lt;/code&gt; 但是我们可以从配置模版开始会更轻松一些。&lt;/p&gt;
&lt;p&gt;比如ramips-mt7621的设备可以用拷贝这个模版&lt;code&gt;feeds/x/rom/lede/config.ramips-mt7621&lt;/code&gt;
内核分区限制小的设备，选用 &lt;code&gt;-nosymbol&lt;/code&gt; 结尾的&lt;code&gt;config&lt;/code&gt;配置模版&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp feeds/x/rom/lede/config.ramips-mt7621 .config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于这些模版是用来编译大量设备的，copy过来后，可以直接编译，不做任何改变。
但是如果需要改变，需要&lt;code&gt;make menuconfig&lt;/code&gt;自定义，就要做下面的操作:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 上面已经cp 拷贝了模版配置到 .config
# 例如 cp feeds/x/rom/lede/config.ramips-mt7621 .config
# 下面继续操作和修改

#1 执行
make menuconfig

#2 进入 Target Profile 选择需要编译打包的设备型号，选择型号后立刻退出，保存
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn2.xcqcoo.top/gh/x-wrt/x-wrt.github.io@master/docs/build/build-target.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#3 执行下面的命令修复 .config
sh feeds/x/rom/lede/fix-config.sh

#4 再次执行 make menuconfig 然后立刻退出保存

#5 最后一次 执行 make menuconfig 自定义选择你需要的软件包

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有更多配置模版，请参考目录下的&lt;code&gt;config.*&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;feeds/x/rom/lede/config.ath79-generic
feeds/x/rom/lede/config.ath79-generic-nosymbol
feeds/x/rom/lede/config.ath79-nand
feeds/x/rom/lede/config.bcm27xx-bcm2709
feeds/x/rom/lede/config.bcm27xx-bcm2710
feeds/x/rom/lede/config.bcm27xx-bcm2711
feeds/x/rom/lede/config.bcm4908-generic
feeds/x/rom/lede/config.bcm53xx-generic
feeds/x/rom/lede/config.ipq40xx-generic
feeds/x/rom/lede/config.ipq806x-generic
feeds/x/rom/lede/config.kirkwood-generic
feeds/x/rom/lede/config.mediatek-mt7622
feeds/x/rom/lede/config.mvebu-cortexa53
feeds/x/rom/lede/config.mvebu-cortexa9
feeds/x/rom/lede/config.ramips-mt7620
feeds/x/rom/lede/config.ramips-mt7620-nosymbol
feeds/x/rom/lede/config.ramips-mt7621
feeds/x/rom/lede/config.ramips-mt76x8
feeds/x/rom/lede/config.ramips-mt76x8-nosymbol
feeds/x/rom/lede/config.ramips-rt305x
feeds/x/rom/lede/config.ramips-rt3883-nosymbol
feeds/x/rom/lede/config.rockchip-armv8
feeds/x/rom/lede/config.sunxi-cortexa7
feeds/x/rom/lede/config.x86_64
feeds/x/rom/lede/config.x86_64-docker
feeds/x/rom/lede/config.x86_generic
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2. 配置目标&lt;/h2&gt;
&lt;p&gt;在上述准备好的模版配置文件的基础上，执行&lt;code&gt;make menuconfig&lt;/code&gt;命令进行个性化定制，增删应用。&lt;/p&gt;
&lt;p&gt;定位到各个子菜单，选择对应的软件包
&lt;img src=&quot;https://cdn2.xcqcoo.top/gh/x-wrt/x-wrt.github.io@master/docs/build//build-m.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;3. 执行编译&lt;/h2&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make -j1 V=s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的包在&lt;code&gt;bin/targets/&lt;/code&gt;下面&lt;/p&gt;
&lt;p&gt;如果需要再次修改配置编译，只要不是换设备，都可以直接 &lt;code&gt;make menuconfig&lt;/code&gt; 修改后就编译，如果需要修改设备，请从拷贝模版配置的地方重新开始配置。&lt;/p&gt;
&lt;h2&gt;3. 高阶配置&lt;/h2&gt;
&lt;p&gt;为了得到满意的固件，下面对编译配置选项做更多的详细说明，但是更多的可能并不局限于这些说明内容，还有更多期待大家自己探索。&lt;/p&gt;
&lt;h3&gt;3.1 选择应用&lt;/h3&gt;
&lt;p&gt;首先，进入&lt;code&gt;make menuconfig&lt;/code&gt;菜单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要编译到固件里面，就要选择&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;，如果只选择&lt;code&gt;&amp;lt;M&amp;gt;&lt;/code&gt;只是编译成软件包&lt;code&gt;ipk&lt;/code&gt;，不会打包进入固件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;LuCI - Applications&lt;/code&gt;子菜单下面，选择自己想要的应用&lt;/p&gt;
&lt;p&gt;常见的软件包:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;luci-app-aria2 ARRIA2下载工具
luci-app-ddns DDNS工具
luci-app-mwan3 MWAN3负载均衡
luci-app-openvpn OPENVPN
luci-app-ksmbd Ksmbd文件网络共享（samba文件共享）
luci-app-upnp UPNP设置
luci-app-wireguard WireGuard配置界面
luci-app-natcap 远程界面管理模块和全锥形nat实现模块
luci-app-natflow-users 用户认证（用户流量显示）模块
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;Kernel modules - USB Support&lt;/code&gt;菜单，选择USB支持的驱动&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;Kernel modules - Filesystems&lt;/code&gt;菜单，选择需要支持的文件系统，比如&lt;code&gt;ext4,ntfs,vfat&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;Kernel modules - Wireless Drivers&lt;/code&gt;菜单，选择无线支持的驱动，如果需要挂卡的驱动，也是在这里找&lt;/p&gt;
&lt;h3&gt;3.2 关于natcap远程管理模块&lt;/h3&gt;
&lt;p&gt;这个模块包含这几个方面功能的实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程界面管理(http://x-wrt.dev/) 模块&lt;/li&gt;
&lt;li&gt;全锥形nat实现模块&lt;/li&gt;
&lt;li&gt;一键VPN功能易用功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;鉴于有些朋友不喜欢远程管理，这里说明下如何去掉这个模块，请自行选择是否需要这个模块。删除后就删除了这个功能包括全锥形nat功能和一键VPN功能，抱歉这些暂时是耦合的无法分离，远程管理界面需要连接中转服务器和报告动态DNS数据，才能生成根据mac地址匹配的动态域名，如果有公网IP才会生成对应的mac域名给一键VPN功能使用。&lt;/p&gt;
&lt;p&gt;编译选择不集成这个模块，可以:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改.config文件，删去掉这几个模块
CONFIG_PACKAGE_luci-app-natcap=y
CONFIG_PACKAGE_natcapd-client=y
CONFIG_PACKAGE_natcapd-server=y
CONFIG_PACKAGE_natcapd=y
CONFIG_PACKAGE_kmod-natcap=y

# 为了单独让natflow软件加速功能工作，选择下面的包
CONFIG_PACKAGE_natflow-boot=y
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>自己动手编译 OpenWRT</title><link>https://blog.xcqcoo.top/posts/diy-openwrt/</link><guid isPermaLink="true">https://blog.xcqcoo.top/posts/diy-openwrt/</guid><description>如何自己编译OpenWrt</description><pubDate>Thu, 08 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;文章来源：https://lgiki.net/post/compile-openwrt/&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;学校最近升级了校园网设备，终于从年久失修的龟速 100Mbps 升级到了 1Gbps，尽管还是使用锐捷的 ePortal 网页认证，还能通过简单的 Shell 脚本在路由器上自动认证，但新设备却限制了每个用户最多只能同时有两台设备在线，使用路由器会被检测出使用多设备，并被加入黑名单，被断网。&lt;/p&gt;
&lt;p&gt;都 2023 年了，随便手机、电脑再加个平板就仨设备了，更不用说可能还有 Kindle、Switch 等其他设备，只能同时两台设备在线怎么可能满足学生正常使用校园网的需求。更何况，计算机专业的学生可能还会使用虚拟机等软件，但虚拟机类的软件也可能被检测为是多设备同时在线，所以你让计算机专业的学生拿啥学习呢，内存条含嘴里脑补画面吗？&lt;/p&gt;
&lt;p&gt;限制校园网的同时在线设备数量无非就两个出发点：（1）如果不限制，一个宿舍只需要开通一个宽带账号，所有人都可以上网了，运营商的收入就减少了；（2）如果学生出现一些非法的上网行为，可以快速准确地定位到具体学生。但我觉得这都不是学校限制学生只能使用两个设备的理由，哪怕提升到 5 个设备我觉得也合理一些。&lt;/p&gt;
&lt;p&gt;对于限制校园网设备数量的学校，我只能说 Shame on you！&lt;/p&gt;
&lt;p&gt;对于限制校园网设备数量的学校，我只能说 Shame on you！&lt;/p&gt;
&lt;p&gt;对于限制校园网设备数量的学校，我只能说 Shame on you！&lt;/p&gt;
&lt;p&gt;那就…只能另辟蹊径，想其他办法了。&lt;/p&gt;
&lt;p&gt;还好，限制同时在线设备数量这件事早已有其他学校实施过了，也已经有人提出了一些对策。
例如，在 https://blog.sunbk201.site/posts/crack-campus-network 这篇博客里就详细列举了校园网检测在线设备可能采用的手段以及相应的应对措施，我们只需要照着做就行了。&lt;/p&gt;
&lt;p&gt;其实主要就是为 OpenWRT 编译 &lt;a href=&quot;https://github.com/CHN-beta/rkp-ipid&quot;&gt;rkp-ipid&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Zxilly/UA2F&quot;&gt;UA2F&lt;/a&gt; 这两个包，而这两个包需要在编译内核的时候开启一些选项，所以需要重新编译 OpenWRT 固件，也因此写下这篇文章记录一下编译 OpenWRT 的过程。&lt;/p&gt;
&lt;h2&gt;安装编译环境&lt;/h2&gt;
&lt;p&gt;要编译 Linux 当然是使用 Linux 啦！&lt;/p&gt;
&lt;p&gt;如果是 Debian 系的发行版（例如 Ubuntu），可以使用以下指令来安装编译所需的依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update -y
sudo apt full-upgrade -y
sudo apt install -y ack antlr3 aria2 asciidoc autoconf automake autopoint binutils bison build-essential \
bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \
git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev \
libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libreadline-dev libssl-dev libtool lrzsz \
mkisofs msmtp nano ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 python3-pip libpython3-dev qemu-utils \
rsync scons squashfs-tools subversion swig texinfo uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于 Arch 系的发行版，直接安装 AUR 中的 openwrt-devel 即可：
https://aur.archlinux.org/packages/openwrt-devel&lt;/p&gt;
&lt;h2&gt;获取 OpenWRT 源码&lt;/h2&gt;
&lt;p&gt;如果你的设备是 OpenWRT 官方支持的设备，并且你想编译 OpenWRT 官方源码，则直接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/openwrt/openwrt.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;p&gt;但现在有一些国产的路由器 OpenWRT 官方并不支持，可以看看有没有第三方的 OpenWRT 源码支持了你手上的路由器，下载相应的源代码。
可以通过&lt;code&gt;cat /etc/openwrt_release&lt;/code&gt;命令来查看设备的 Arch、Target 信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@QWRT:~# cat /etc/openwrt_release
DISTRIB_ID=&apos;OpenWrt&apos;
DISTRIB_RELEASE=&apos;19.07-SNAPSHOT&apos;
DISTRIB_TARGET=&apos;ipq60xx/generic&apos;
DISTRIB_ARCH=&apos;aarch64_cortex-a53+crypto&apos;
DISTRIB_TAINTS=&apos;no-all busybox override&apos;
DISTRIB_REVISION=&apos;R23.1.20&apos;
DISTRIB_DESCRIPTION=&apos;QWRT &apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取了 OpenWRT 源代码之后需要更新 Feeds：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd openwrt
./scripts/feeds update -a
./scripts/feeds install -a
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;添加想要编译的第三方包 (可选)&lt;/h2&gt;
&lt;p&gt;因为我需要编译 rkp-ipid 和 UA2F，因此我还需要将这些包的源码下载下来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/CHN-beta/rkp-ipid package/rkp-ipid
git clone https://github.com/Zxilly/UA2F package/UA2F
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;配置编译目标&lt;/h2&gt;
&lt;p&gt;一切准备就绪，接下来就是设定编译目标了，执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后会出现一个命令行 UI，首先需要重点设定好&lt;code&gt;Target System&lt;/code&gt;,&lt;code&gt;Subtarget&lt;/code&gt;,&lt;code&gt;Target Profile&lt;/code&gt;，将这几个项目设定为你的路由器。 然后就可以选择你需要编译的包啦，使用空格可以选择要编译的包，设定为 &amp;lt;*&amp;gt; 的包将会内置到固件里，刷好就能直接用，设定为 &amp;lt;M&amp;gt; 的包将会编译成 ipk 文件，需要上传到路由器，然后使用&lt;code&gt;opkg install package_name.ipk&lt;/code&gt;进行安装。&lt;/p&gt;
&lt;p&gt;设定好了之后，将配置文件保存为&lt;code&gt;.config&lt;/code&gt;即可，如果有一些包需要对内核做一些自定义，也可以直接使用文本编辑器编辑保存下来的&lt;code&gt;.config&lt;/code&gt;文件，例如&lt;code&gt;UA2F&lt;/code&gt;就需要添加&lt;code&gt;CONFIG_NETFILTER_NETLINK_GLUE_CT=y&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;开始编译&lt;/h2&gt;
&lt;p&gt;一切准备完毕，接下来开始编译！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make download -j8
make V=s -j8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;V=s&lt;/code&gt;表示输出&lt;code&gt;stdout&lt;/code&gt;和&lt;code&gt;stderr&lt;/code&gt;，方便在编译失败的时候根据输出信息确定是哪里的错误，&lt;code&gt;-jn&lt;/code&gt;的&lt;code&gt;n&lt;/code&gt;表示使用&lt;code&gt;n&lt;/code&gt;个线程同时编译，对于核心数较多的机器可以将该数值设置得大一些，加快编译过程。&lt;/p&gt;
&lt;p&gt;编译完成之后，在&lt;code&gt;./bin/targets&lt;/code&gt;下就可以找到固件以及相应的&lt;code&gt;ipk&lt;/code&gt;包了。&lt;/p&gt;
&lt;h2&gt;UA2F 的注意事项&lt;/h2&gt;
&lt;p&gt;要使 UA2F 正常工作需要关闭 “网络”——“Turbo ACC 网络加速设置” 下的所有选项，否则 UA2F 无法正常工作，具体表现为：重启路由器防火墙之后，第一次 HTTP 请求的 User-Agent 成功修改，但后续 HTTP 请求的 User-Agent 没有被修改。&lt;/p&gt;
</content:encoded></item></channel></rss>